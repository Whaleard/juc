# juc
JUC
    java.util.concurrent相关工具包的简称

进程、线程和管程
    进程：资源分配的最小单位
    线程：cpu调度和执行的最小单位
    管程：Monitor(监视器)，一种同步机制，也就是锁

线程状态：
    NEW（新建）：线程对象通过new Thread()创建后但未调用start()方法时的状态，此时线程尚未启动。
    RUNNABLE（可运行）：调用start()方法后，线程进入此状态，包含两种情况
        Ready：等待cpu调度
        Running：正在执行任务
    BLOCKED（阻塞）：线程因竞争同步锁（如synchronized）失败而被阻塞，直到获取锁后重新进入RUNNABLE状态。
    WAITING（等待）：线程主动调用wait()、join()等方法进入此状态，需其他线程显示唤醒（如notify()）。
    TIMED_WAITING（计时等待）：与WAITING类似，但通过sleep(time)或wait(time)等方法设置超时时间，时间结束后自动恢复。
    TERMINATED（终止）：线程执行完run()方法或异常退出后的最终状态，不可重启。

sleep()和wait()
    相同点：
        1、都可以被interrupted方法中断。
        2、方法在哪里中断，就在哪里被唤醒。
    不同点：
        1、sleep()是Thread的静态方法；wait()是Object的方法，任何对象实例都能调用。
        2、sleep()调用后不会释放持有的锁，调用前也不需要占用锁；wait()调用后会‌立即释放锁‌，但调用它的前提是当前线程占有锁（即代码要在synchronized中）。

用户线程和守护线程
    用户线程：系统的工作线程，完成这个程序需要完成的业务操作
    守护线程：一种特殊的为其他线程服务的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程
            守护线程作为一个服务线程，没有服务对象就没有必要继续运行了。如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。
            所以假如当系统只剩下守护线程的时候，java虚拟机会自动退出
    注意：如果用户线程全部结束意味着程序需要完成的业务操作已经结束了，守护线程随着JVM一同结束工作
         setDaemon(true)方法必须在start()之前设置，否则报IllegalThreadStateException异常

Runnable接口与Callable接口的不同点
    Runnable接口的run()方法没有返回值，方法上无法声明throws
    Callable接口的call()方法有返回值，方法上可以声明throws

Future接口
    Future接口定义了操作异步任务执行的一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。实现类为FutureTask
    Future接口可以为主线程开一个分支任务，专门为主线程处理耗时费力的复杂业务，让主线程继续处理其他任务或者先行结束，再通过Future获取计算结果

Lock和synchronized相同点：
    1、都是可重入锁
Lock和synchronized不同点：
    1、Lock是一个接口，synchronized是关键字
    2、synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
    3、Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断
    4、通过Lock可以知道有没有成功获取锁，而synchronized却无法办到
    5、Lock可以提高多个线程进行读操作的效率
    注：在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争

乐观锁和悲观锁
    乐观锁：认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源是否被其它线程修改了
    悲观锁：认为共享资源每次被访问的时候就会出现问题，所以在每次获取资源操作的时候都会上锁 

表锁和行锁
