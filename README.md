# juc
进程、线程和管程
    进程：资源分配的最小单位
    线程：CPU调度和执行的最小单位
    管程：Monitor(监视器)，一种同步机制，也就是锁

用户线程和守护线程
    用户线程：系统的工作线程，完成这个程序需要完成的业务操作
    守护线程：一种特殊的为其他线程服务的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程
            守护线程作为一个服务线程，没有服务对象就没有必要继续运行了。如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。
            所以假如当系统只剩下守护线程的时候，java虚拟机会自动退出
    注意：如果用户线程全部结束意味着程序需要完成的业务操作已经结束了，守护线程随着JVM一同结束工作
         setDaemon(true)方法必须在start()之前设置，否则报IllegalThreadStateException异常

Runnable接口与Callable接口的不同点
    Runnable接口的run()方法没有返回值，方法上无法声明throws
    Callable接口的call()方法有返回值，方法上可以声明throws

Future接口
    Future接口定义了操作异步任务执行的一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。实现类为FutureTask
    Future接口可以为主线程开一个分支任务，专门为主线程处理耗时费力的复杂业务，让主线程继续处理其他任务或者先行结束，再通过Future获取计算结果

Lock和synchronized相同点：
    1、都是可重入锁
Lock和synchronized不同点：
    1、Lock是一个接口，synchronized是关键字
    2、synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unlock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
    3、Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断
    4、通过Lock可以知道有没有成功获取锁，而synchronized却无法办到
    5、Lock可以提高多个线程进行读操作的效率
    注：在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争

sleep()和wait()不同点：
    1、sleep()调用后不会释放持有的锁，wait()调用后会‌立即释放锁‌